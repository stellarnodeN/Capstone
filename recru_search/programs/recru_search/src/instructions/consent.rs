use anchor_lang::prelude::*;
use mpl_core::{
    ID as MPL_CORE_ID,
    instructions::{BurnV1, BurnV1InstructionArgs, CreateV1, CreateV1InstructionArgs},
};
use crate::state::{
    study::{StudyAccount, StudyStatus},
    nft::ConsentAccount,
    submission::SubmissionAccount,
};
use crate::error::RecruSearchError;
use crate::constants::*;

#[derive(Accounts)]
#[instruction(study_id: u64)]
pub struct MintConsentNFT<'info> {
    #[account(
        seeds = [STUDY_SEED.as_bytes(), study.researcher.key().as_ref(), study_id.to_le_bytes().as_ref()],
        bump = study.bump,
        constraint = study.status == StudyStatus::Published @ RecruSearchError::StudyNotPublished,
        constraint = study.enrolled_count < study.max_participants @ RecruSearchError::StudyFull
    )]
    pub study: Account<'info, StudyAccount>,

    #[account(
        init,
        payer = participant,
        space = 8 + ConsentAccount::INIT_SPACE,
        seeds = [
            CONSENT_SEED.as_bytes(),
            study.key().as_ref(),
            participant.key().as_ref()
        ],
        bump
    )]
    pub consent: Account<'info, ConsentAccount>,

    /// Consent NFT mint account (new keypair generated by participant)
    #[account(mut)]
    pub consent_nft_mint: Signer<'info>,

    #[account(mut)]
    pub participant: Signer<'info>,
    
    pub system_program: Program<'info, System>,

    /// CHECK: Metaplex Core Program for NFT creation
    #[account(address = MPL_CORE_ID)]
    pub mpl_core_program: UncheckedAccount<'info>,
}

#[derive(Accounts)]
pub struct RevokeConsent<'info> {
    #[account(
        mut,
        seeds = [
            CONSENT_SEED.as_bytes(),
            consent.study.as_ref(),
            participant.key().as_ref()
        ],
        bump = consent.bump,
        constraint = consent.participant == participant.key() @ RecruSearchError::UnauthorizedParticipant,
        constraint = !consent.is_revoked @ RecruSearchError::ConsentRevoked
    )]
    pub consent: Account<'info, ConsentAccount>,

    #[account(mut)]
    pub consent_nft_mint: Account<'info, anchor_spl::token::Mint>,

    #[account(mut)]
    pub participant: Signer<'info>,

    /// CHECK: Check if participant has submitted data - if so, prevent consent revocation
    #[account(
        seeds = [
            SUBMISSION_SEED.as_bytes(),
            consent.study.as_ref(),
            participant.key().as_ref()
        ],
        bump
    )]
    pub submission: Option<Account<'info, SubmissionAccount>>,

    /// CHECK: Metaplex Core Program for burning NFT
    #[account(address = MPL_CORE_ID)]
    pub mpl_core_program: UncheckedAccount<'info>,
}

impl<'info> MintConsentNFT<'info> {
    pub fn mint_consent_nft(&mut self, study_id: u64, eligibility_proof: Vec<u8>) -> Result<()> {
        // Basic validation - replace with actual verification
        require!(eligibility_proof.len() > 0, RecruSearchError::InvalidEligibilityProof);
        
        let study = &self.study;
        let clock = Clock::get()?;
        
        // Verify study is in enrollment period
        require!(
            clock.unix_timestamp >= study.enrollment_start && 
            clock.unix_timestamp <= study.enrollment_end,
            RecruSearchError::InvalidEnrollmentPeriod
        );

        // Initialize ConsentAccount (moved from state/nft.rs)
        let consent = &mut self.consent;
        consent.participant = self.participant.key();
        consent.study = study.key();
        consent.timestamp = clock.unix_timestamp;
        consent.is_revoked = false;
        consent.revocation_timestamp = None;
        consent.eligibility_proof = eligibility_proof;
        consent.nft_mint = Some(self.consent_nft_mint.key());
        consent.bump = 0; // Will be set by Anchor

        // Create Consent NFT using Metaplex Core (simplified)
        let metadata_uri = format!("https://api.recrusearch.com/consent/{}", study.study_id);
        let consent_nft_name = format!("RecruSearch Consent #{}", study.study_id);
        
        let create_ix = CreateV1 {
            asset: self.consent_nft_mint.key(),
            collection: None,
            authority: Some(self.participant.key()),
            payer: self.participant.key(),
            owner: Some(self.participant.key()),
            update_authority: Some(self.participant.key()),
            system_program: self.system_program.key(),
            log_wrapper: None,
        };

        let create_ix_args = CreateV1InstructionArgs {
            data_state: mpl_core::types::DataState::AccountState,
            name: consent_nft_name,
            uri: metadata_uri,
            plugins: None,
        };

        anchor_lang::solana_program::program::invoke(
            &create_ix.instruction(create_ix_args),
            &[
                self.consent_nft_mint.to_account_info(),
                self.participant.to_account_info(),
                self.system_program.to_account_info(),
                self.mpl_core_program.to_account_info(),
            ],
        )?;

        msg!("SUCCESS: Consent NFT minted for participant: {}", self.participant.key());
        msg!("Consent NFT mint: {}", self.consent_nft_mint.key());
        msg!("Study ID: {}", study.study_id);

        Ok(())
    }
}

impl<'info> RevokeConsent<'info> {
    pub fn revoke_consent(&mut self) -> Result<()> {
        // Check if participant has submitted data - prevent revocation if they have
        if let Some(_submission) = &self.submission {
            msg!("ERROR: Cannot revoke consent after data submission");
            return Err(RecruSearchError::AlreadySubmitted.into());
        }

        // Mark consent as revoked
        let consent = &mut self.consent;
        consent.is_revoked = true;
        consent.revocation_timestamp = Some(Clock::get()?.unix_timestamp);

        // Burn the Consent NFT using Metaplex Core (simplified)
        let burn_ix = BurnV1 {
            asset: self.consent_nft_mint.key(),
            collection: None,
            payer: self.participant.key(),
            authority: Some(self.participant.key()),
            system_program: None,
            log_wrapper: None,
        };

        let burn_ix_args = BurnV1InstructionArgs {
            compression_proof: None,
        };

        anchor_lang::solana_program::program::invoke(
            &burn_ix.instruction(burn_ix_args),
            &[
                self.consent_nft_mint.to_account_info(),
                self.participant.to_account_info(),
                self.mpl_core_program.to_account_info(),
            ],
        )?;

        msg!("SUCCESS: Consent revoked and NFT burned for participant: {}", self.participant.key());
        
        Ok(())
    }
}